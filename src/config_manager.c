/**
 * @file config_manager.c
 * @brief Runtime configuration management system for DexDumper
 * 
 * This module handles loading, parsing, and managing runtime configuration
 * from external files. It allows users to customize dumper behavior without
 * recompiling the library.
 */

#include "config_manager.h"
#include "file_utils.h"

/**
 * @brief Runtime configuration structure
 * 
 * Holds all configurable parameters that can be modified at runtime
 * through configuration files. This structure is populated when the
 * configuration manager is initialized.
 */
typedef struct {
    int enable_second_scan;              // Enable/disable second memory scan
    int thread_initial_delay;            // Initial delay before first scan (seconds)
    int second_scan_delay;               // Delay between scans (seconds)
    int enable_region_filtering;         // Enable smart memory region filtering
    char** excluded_sha1_list;           // List of SHA1 hashes to exclude from dumping
    int excluded_sha1_count;             // Number of excluded SHA1 entries
    char** output_directory_templates;   // Template paths for output directories
    int output_directory_count;          // Number of output directory templates
    int config_loaded;                   // Flag indicating if config was successfully loaded
} RuntimeConfig;

// Global runtime configuration instance
static RuntimeConfig g_runtime_config;

/**
 * @brief Extracts base library name from full path
 * 
 * This function extracts the base name of the shared library (without
 * "lib" prefix and ".so" extension) to use in configuration file naming.
 * 
 * @return char* Base library name (e.g., "dexdumper" from "libdexdumper.so")
 * @note Caller must free the returned string
 */
static char* get_library_basename(void) {
    Dl_info info;
    // Get information about the current function's location in the library
    if (dladdr((void*)get_library_basename, &info) == 0 || !info.dli_fname) {
        return NULL;
    }
    
    const char* so_path = info.dli_fname;
    const char* filename = strrchr(so_path, '/');
    filename = filename ? filename + 1 : so_path;
    
    size_t len = strlen(filename);
    
    // Check if filename follows standard library naming: lib<name>.so
    if (len > 6 && strncmp(filename, "lib", 3) == 0 && 
        strcmp(filename + len - 3, ".so") == 0) {
        
        // Extract the middle part (name without lib prefix and .so extension)
        char* result = malloc(len - 5 + 1); // -5 for "lib" and ".so"
        if (!result) return NULL;
        
        memcpy(result, filename + 3, len - 6);
        result[len - 6] = '\0';
        LOGI("Library base name: %s", result);
        return result;
    }
    
    return NULL;
}

/**
 * @brief Gets the full library filename
 * 
 * @return char* Full library filename (e.g., "libdexdumper.so")
 * @note Caller must free the returned string
 */
static char* get_full_library_name(void) {
    Dl_info info;
    if (dladdr((void*)get_full_library_name, &info) == 0 || !info.dli_fname) {
        return NULL;
    }
    
    const char* so_path = info.dli_fname;
    const char* filename = strrchr(so_path, '/');
    filename = filename ? filename + 1 : so_path;
    
    char* result = strdup(filename);
    LOGI("Full library name: %s", result);
    return result;
}

/**
 * @brief Creates a default configuration file with detailed comments
 * 
 * This function generates a comprehensive configuration file with
 * explanations for each setting, making it easy for users to understand
 * and customize the dumper's behavior.
 * 
 * @param config_path Path where the configuration file should be created
 */
static void create_default_config(const char* config_path) {
    FILE* config_file = fopen(config_path, "w");
    if (!config_file) {
        LOGW("Failed to create default configuration file: %s", config_path);
        return;
    }
    
    LOGI("Creating default configuration file: %s", config_path);
    
    char* full_lib_name = get_full_library_name();
    
    // Write comprehensive header with documentation
    fprintf(config_file, "# ================================================\n");
    fprintf(config_file, "# DexDumper Runtime Configuration File\n");
    fprintf(config_file, "#\n");
    fprintf(config_file, "# DexDumper - Memory-based DEX Extraction Library:\n");
    fprintf(config_file, "# https://github.com/muhammadrizwan87/dexdumper.git\n");
    fprintf(config_file, "# ================================================\n");
    fprintf(config_file, "#\n");
    if (full_lib_name) {
        fprintf(config_file, "# This file was automatically generated by %s\n", full_lib_name);
    } else {
        fprintf(config_file, "# This file was automatically generated by libdexdumper.so\n");
    }
    fprintf(config_file, "# Location: %s\n", config_path);
    fprintf(config_file, "# Generated on: %s", ctime(&(time_t){time(NULL)}));
    fprintf(config_file, "#\n");
    fprintf(config_file, "# PURPOSE:\n");
    fprintf(config_file, "# This configuration file allows you to customize the behavior\n");
    fprintf(config_file, "# of the DexDumper library at runtime without recompiling.\n");
    fprintf(config_file, "#\n");
    fprintf(config_file, "# USAGE:\n");
    fprintf(config_file, "# 1. Modify the values below as needed\n");
    fprintf(config_file, "# 2. Save the file\n");
    fprintf(config_file, "# 3. Restart the target application\n");
    fprintf(config_file, "#\n");
    fprintf(config_file, "# NOTES:\n");
    fprintf(config_file, "# - Lines starting with '#' are comments\n");
    fprintf(config_file, "# - Format: key=value (no spaces around '=')\n");
    fprintf(config_file, "# - Boolean values: 0 = false, 1 = true\n");
    fprintf(config_file, "# ================================================\n\n");
    
    // Write configuration sections with detailed explanations
    fprintf(config_file, "# SCANNING BEHAVIOR CONFIGURATION\n");
    fprintf(config_file, "# ================================\n");
    fprintf(config_file, "\n");
    
    fprintf(config_file, "# Enable or disable the second memory scan\n");
    fprintf(config_file, "# Some applications load DEX files dynamically after initial startup\n");
    fprintf(config_file, "# Second scan can catch these late-loaded DEX files\n");
    fprintf(config_file, "# Default: %d (0=disabled, 1=enabled)\n", ENABLE_SECOND_SCAN);
    fprintf(config_file, "enable_second_scan=%d\n\n", ENABLE_SECOND_SCAN);
    
    fprintf(config_file, "# Initial delay in seconds before starting first memory scan\n");
    fprintf(config_file, "# Allows application to fully initialize before scanning\n");
    fprintf(config_file, "# Recommended: 5-15 seconds depending on app startup time\n");
    fprintf(config_file, "# Default: %d seconds\n", THREAD_INITIAL_DELAY);
    fprintf(config_file, "thread_initial_delay=%d\n\n", THREAD_INITIAL_DELAY);
    
    fprintf(config_file, "# Delay between first and second scan (if second scan is enabled)\n");
    fprintf(config_file, "# Gives time for dynamic DEX loading to occur\n");
    fprintf(config_file, "# Default: %d seconds\n", SECOND_SCAN_DELAY);
    fprintf(config_file, "second_scan_delay=%d\n\n", SECOND_SCAN_DELAY);
    
    fprintf(config_file, "# Enable smart memory region filtering\n");
    fprintf(config_file, "# Filters out unlikely memory regions to improve performance\n");
    fprintf(config_file, "# and reduce false positives\n");
    fprintf(config_file, "# Effect of disabling: Scans ALL memory regions including system areas\n");
    fprintf(config_file, "# Default: %d (0=disabled, 1=enabled)\n", ENABLE_REGION_FILTERING);
    fprintf(config_file, "enable_region_filtering=%d\n\n", ENABLE_REGION_FILTERING);
    
    // DEX exclusions section
    fprintf(config_file, "# DEX FILE EXCLUSIONS\n");
    fprintf(config_file, "# ===================\n");
    fprintf(config_file, "# Add SHA1 hashes of DEX files you want to exclude from dumping\n");
    fprintf(config_file, "# Useful for excluding system DEX files or known false positives\n");
    fprintf(config_file, "# Format: excluded_sha1=40_character_sha1_hash\n");
    fprintf(config_file, "# Example: excluded_sha1=da39a3ee5e6b4b0d3255bfef95601890afd80709\n");
    fprintf(config_file, "# Default exclusions (system/empty files):\n");
    
    const char* default_exclusions[] = EXCLUDED_SHA1_LIST;
    int default_count = sizeof(default_exclusions) / sizeof(default_exclusions[0]);
    for (int i = 0; i < default_count; i++) {
        fprintf(config_file, "excluded_sha1=%s\n", default_exclusions[i]);
    }
    fprintf(config_file, "\n");
    
    // Output directory configuration
    fprintf(config_file, "# OUTPUT DIRECTORY CONFIGURATION\n");
    fprintf(config_file, "# ==============================\n");
    fprintf(config_file, "# Specify where dumped DEX files should be saved\n");
    fprintf(config_file, "# %%s will be replaced with current package name\n");
    fprintf(config_file, "# Multiple directories can be specified - first writable one is used\n");
    fprintf(config_file, "# Format: output_directory_templates=path/with/%%s/placeholder\n");
    fprintf(config_file, "# NOTE: Default paths are within app's self directories (no extra permissions needed).\n");
    fprintf(config_file, "# If using custom directories, ensure proper Android permissions are granted.\n");
    fprintf(config_file, "\n");
    fprintf(config_file, "# Default output directories (in order of preference):\n");
    
    const char* default_templates[] = OUTPUT_DIRECTORY_TEMPLATES;
    int template_count = sizeof(default_templates) / sizeof(default_templates[0]);
    for (int i = 0; i < template_count; i++) {
        fprintf(config_file, "output_directory_templates=%s\n", default_templates[i]);
    }
    
    fprintf(config_file, "\n");
    fprintf(config_file, "# END OF CONFIGURATION FILE\n");
    
    fclose(config_file);
    if (full_lib_name) free(full_lib_name);
    LOGI("Default configuration file created successfully with detailed comments");
}

/**
 * @brief Ensures that a directory path exists, creating it if necessary
 * 
 * This function checks if the directory containing a file path exists
 * and creates it if it doesn't. This is used to ensure configuration
 * and output directories are available.
 * 
 * @param path File path whose parent directory should be checked/created
 * @return int 1 if directory exists or was created, 0 otherwise
 */
static int ensure_directory_exists(const char* path) {
    char* path_copy = strdup(path);
    if (!path_copy) return 0;
    
    // Extract directory part from full path
    char* dir = dirname(path_copy);
    int result = 0;
    
    // Check if directory exists
    if (access(dir, F_OK) != 0) {
        // Directory doesn't exist, try to create it
        if (mkdir(dir, 0755) == 0) {
            LOGI("Created directory: %s", dir);
            result = 1;
        } else {
            LOGW("Failed to create directory: %s", dir);
        }
    } else {
        // Directory exists, check if it's writable
        if (access(dir, W_OK) == 0) {
            result = 1;
        }
    }
    
    free(path_copy);
    return result;
}

/**
 * @brief Finds a writable location for configuration files
 * 
 * This function searches through possible storage locations to find
 * a directory where configuration files can be written. It tries
 * multiple locations in order of preference.
 * 
 * @return const char* Path to writable configuration directory, or NULL if none found
 */
static const char* get_writable_config_path(void) {
    static char config_path[MAX_PATH_LENGTH];
    const char* package_name = get_current_package_name();
    char* base_name = get_library_basename();
    const char* config_filename = base_name ? base_name : "dexdumper";

    // Possible configuration file locations in order of preference
    const char* config_locations[] = {
        "/data/data/%s/files/%s.conf",                    // App's private storage
        "/data/user/0/%s/files/%s.conf",                  // Multi-user private storage  
        "/storage/emulated/0/Android/data/%s/files/%s.conf", // External app storage
        "/sdcard/Android/data/%s/files/%s.conf"           // Legacy external storage
    };

    size_t location_count = sizeof(config_locations) / sizeof(config_locations[0]);

    // Try each location until we find one that's writable
    for (size_t i = 0; i < location_count; i++) {
        snprintf(config_path, sizeof(config_path), config_locations[i], package_name, config_filename);
        
        if (ensure_directory_exists(config_path)) {
            LOGI("Selected writable config location: %s", config_path);
            if (base_name) free(base_name);
            return config_path;
        }
    }

    if (base_name) free(base_name);
    return NULL;
}

/**
 * @brief Gets the path to the configuration file
 * 
 * This function searches for an existing configuration file or
 * creates a default one if none exists. It returns the path to
 * the configuration file to use.
 * 
 * @return const char* Path to configuration file, or NULL if none available
 */
static const char* get_config_file_path(void) {
    static char config_path[MAX_PATH_LENGTH];
    const char* package_name = get_current_package_name();

    char* base_name = get_library_basename();
    const char* config_filename = base_name ? base_name : "dexdumper";

    // Possible configuration file locations
    const char* config_locations[] = {
        "/data/data/%s/files/%s.conf",
        "/data/user/0/%s/files/%s.conf", 
        "/storage/emulated/0/Android/data/%s/files/%s.conf",
        "/sdcard/Android/data/%s/files/%s.conf"
    };

    size_t location_count = sizeof(config_locations) / sizeof(config_locations[0]);

    // First, check if configuration file already exists
    for (size_t i = 0; i < location_count; i++) {
        snprintf(config_path, sizeof(config_path), config_locations[i], package_name, config_filename);
        
        FILE* test_file = fopen(config_path, "r");
        if (test_file) {
            fclose(test_file);
            LOGI("Found existing config: %s", config_path);
            if (base_name) free(base_name);
            return config_path;
        }
    }

    // No existing config found, create a default one
    const char* writable_path = get_writable_config_path();
    if (writable_path) {
        strncpy(config_path, writable_path, sizeof(config_path) - 1);
        config_path[sizeof(config_path) - 1] = '\0';
        
        create_default_config(config_path);
        
        if (base_name) free(base_name);
        return config_path;
    }

    if (base_name) free(base_name);
    return NULL;
}

/**
 * @brief Loads runtime configuration from file
 * 
 * This function parses the configuration file line by line, extracting
 * key-value pairs and updating the runtime configuration accordingly.
 * It handles various configuration options and maintains backward
 * compatibility with default values.
 */
static void load_runtime_config(void) {
    const char* config_path = get_config_file_path();
    if (!config_path) {
        LOGI("No configuration file found, using default settings");
        return;
    }
    
    FILE* config_file = fopen(config_path, "r");
    if (!config_file) {
        LOGW("Failed to open configuration file: %s", config_path);
        return;
    }
    
    LOGI("Loading runtime configuration from: %s", config_path);
    
    char line[256];
    int line_number = 0;
    
    // Temporary storage for configuration arrays
    char* excluded_sha1_temp[100] = {0};
    int excluded_count = 0;
    
    char* output_templates_temp[100] = {0};
    int output_template_count = 0;
    
    // Read configuration file line by line
    while (fgets(line, sizeof(line), config_file)) {
        line_number++;
        
        // Remove newline character
        line[strcspn(line, "\n")] = 0;
        
        // Skip empty lines and comments
        if (line[0] == '\0' || line[0] == '#') continue;
        
        // Split line into key and value
        char* equals = strchr(line, '=');
        if (!equals) {
            LOGW("Invalid config line %d: %s", line_number, line);
            continue;
        }
        
        *equals = '\0';
        char* key = line;
        char* value = equals + 1;
        
        // Trim whitespace
        while (*key == ' ') key++;
        while (*value == ' ') value++;
        
        // Process different configuration keys
        if (strcmp(key, "enable_second_scan") == 0) {
            g_runtime_config.enable_second_scan = atoi(value);
            LOGI("Runtime config: enable_second_scan = %d", g_runtime_config.enable_second_scan);
        }
        else if (strcmp(key, "thread_initial_delay") == 0) {
            g_runtime_config.thread_initial_delay = atoi(value);
            LOGI("Runtime config: thread_initial_delay = %d", g_runtime_config.thread_initial_delay);
        }
        else if (strcmp(key, "second_scan_delay") == 0) {
            g_runtime_config.second_scan_delay = atoi(value);
            LOGI("Runtime config: second_scan_delay = %d", g_runtime_config.second_scan_delay);
        }
        else if (strcmp(key, "enable_region_filtering") == 0) {
            g_runtime_config.enable_region_filtering = atoi(value);
            LOGI("Runtime config: enable_region_filtering = %d", g_runtime_config.enable_region_filtering);
        }
        else if (strcmp(key, "excluded_sha1") == 0 && strlen(value) == 40) {
            // Validate SHA1 length (40 hex characters)
            if (excluded_count < 100) {
                excluded_sha1_temp[excluded_count] = strdup(value);
                if (excluded_sha1_temp[excluded_count]) {
                    excluded_count++;
                    LOGI("Runtime config: added excluded SHA1: %s", value);
                }
            }
        }
        else if (strcmp(key, "output_directory_templates") == 0) {
            if (output_template_count < 100) {
                output_templates_temp[output_template_count] = strdup(value);
                if (output_templates_temp[output_template_count]) {
                    output_template_count++;
                    LOGI("Runtime config: added output template: %s", value);
                }
            }
        }
    }
    
    fclose(config_file);
    
    // Store excluded SHA1 list in global configuration
    if (excluded_count > 0) {
        g_runtime_config.excluded_sha1_list = malloc(excluded_count * sizeof(char*));
        if (g_runtime_config.excluded_sha1_list) {
            for (int i = 0; i < excluded_count; i++) {
                g_runtime_config.excluded_sha1_list[i] = excluded_sha1_temp[i];
            }
            g_runtime_config.excluded_sha1_count = excluded_count;
            LOGI("Runtime config: loaded %d excluded SHA1 entries", excluded_count);
        }
    }
    
    // Store output directory templates in global configuration
    if (output_template_count > 0) {
        g_runtime_config.output_directory_templates = malloc(output_template_count * sizeof(char*));
        if (g_runtime_config.output_directory_templates) {
            for (int i = 0; i < output_template_count; i++) {
                g_runtime_config.output_directory_templates[i] = output_templates_temp[i];
            }
            g_runtime_config.output_directory_count = output_template_count;
            LOGI("Runtime config: loaded %d output directory templates", output_template_count);
        }
    }
    
    g_runtime_config.config_loaded = 1;
    LOGI("Runtime configuration loaded successfully");
}

/**
 * @brief Initializes the configuration manager
 * 
 * This function sets up the configuration system by:
 * 1. Setting default values from compile-time configuration
 * 2. Attempting to load runtime configuration from file
 * 3. Setting up the global configuration structure
 * 
 * It should be called early in the application lifecycle.
 */
void init_config_manager(void) {
    // Initialize with default values from config.h
    g_runtime_config.enable_second_scan = ENABLE_SECOND_SCAN;
    g_runtime_config.thread_initial_delay = THREAD_INITIAL_DELAY;
    g_runtime_config.second_scan_delay = SECOND_SCAN_DELAY;
    g_runtime_config.enable_region_filtering = ENABLE_REGION_FILTERING;
    g_runtime_config.excluded_sha1_list = NULL;
    g_runtime_config.excluded_sha1_count = 0;
    g_runtime_config.output_directory_templates = NULL;
    g_runtime_config.output_directory_count = 0;
    g_runtime_config.config_loaded = 0;
    
    // Attempt to load configuration from file
    load_runtime_config();
}

/**
 * @brief Cleans up configuration manager resources
 * 
 * This function frees all dynamically allocated memory used by the
 * configuration system. It should be called when the configuration
 * manager is no longer needed.
 */
void cleanup_config_manager(void) {
    // Free excluded SHA1 list
    if (g_runtime_config.excluded_sha1_list) {
        for (int i = 0; i < g_runtime_config.excluded_sha1_count; i++) {
            free(g_runtime_config.excluded_sha1_list[i]);
        }
        free(g_runtime_config.excluded_sha1_list);
    }
    
    // Free output directory templates
    if (g_runtime_config.output_directory_templates) {
        for (int i = 0; i < g_runtime_config.output_directory_count; i++) {
            free(g_runtime_config.output_directory_templates[i]);
        }
        free(g_runtime_config.output_directory_templates);
    }
    
    // Reset configuration structure
    memset(&g_runtime_config, 0, sizeof(g_runtime_config));
    LOGI("Configuration manager cleanup completed");
}

/**
 * @brief Checks if second memory scan should be enabled
 * 
 * @return int 1 if second scan is enabled, 0 otherwise
 */
int should_enable_second_scan(void) {
    return g_runtime_config.enable_second_scan;
}

/**
 * @brief Checks if memory region filtering should be enabled
 * 
 * @return int 1 if region filtering is enabled, 0 otherwise
 */
int should_enable_region_filtering(void) {
    return g_runtime_config.enable_region_filtering;
}

/**
 * @brief Gets the initial delay before first memory scan
 * 
 * @return int Delay in seconds
 */
int get_initial_delay(void) {
    return g_runtime_config.thread_initial_delay;
}

/**
 * @brief Gets the delay between first and second scan
 * 
 * @return int Delay in seconds
 */
int get_second_scan_delay(void) {
    return g_runtime_config.second_scan_delay;
}

/**
 * @brief Gets the list of output directory templates
 * 
 * @param count Output parameter that receives the number of templates
 * @return const char** Array of directory template strings
 */
const char** get_output_directory_templates(int* count) {
    if (g_runtime_config.config_loaded && g_runtime_config.output_directory_count > 0) {
        *count = g_runtime_config.output_directory_count;
        return (const char**)g_runtime_config.output_directory_templates;
    } else {
        // Fall back to compile-time defaults
        static const char* default_templates[] = OUTPUT_DIRECTORY_TEMPLATES;
        *count = sizeof(default_templates) / sizeof(default_templates[0]);
        return default_templates;
    }
}

/**
 * @brief Gets the list of excluded SHA1 hashes
 * 
 * @param count Output parameter that receives the number of excluded hashes
 * @return const char** Array of SHA1 hash strings
 */
const char** get_excluded_sha1_list(int* count) {
    if (g_runtime_config.config_loaded && g_runtime_config.excluded_sha1_count > 0) {
        *count = g_runtime_config.excluded_sha1_count;
        return (const char**)g_runtime_config.excluded_sha1_list;
    } else {
        // Fall back to compile-time defaults
        static const char* default_exclusions[] = EXCLUDED_SHA1_LIST;
        *count = sizeof(default_exclusions) / sizeof(default_exclusions[0]);
        return default_exclusions;
    }
}